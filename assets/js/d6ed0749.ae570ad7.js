"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[133],{3905:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>s,MDXProvider:()=>u,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>m});var t=a(67294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},r.apply(this,arguments)}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function d(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,r({},n,{components:a}))}},p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),m=p(a),u=i,h=m["".concat(o,".").concat(u)]||m[u]||c[u]||r;return a?t.createElement(h,l(l({ref:n},s),{},{components:a})):t.createElement(h,l({ref:n},s))}));function x(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=a[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},31797:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var t=a(87462),i=(a(67294),a(3905));const r={id:"models",title:"Models",sidebar_label:"Models"},o=void 0,l={unversionedId:"models",id:"models",title:"Models",description:"The main way to configure the analysis is through defining models for methods.",source:"@site/documentation/models.md",sourceDirName:".",slug:"/models",permalink:"/docs/models",draft:!1,editUrl:"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/models.md",tags:[],version:"current",frontMatter:{id:"models",title:"Models",sidebar_label:"Models"},sidebar:"docs",previous:{title:"Customize Sources and Sinks",permalink:"/docs/customize-sources-and-sinks"},next:{title:"Shims",permalink:"/docs/shims"}},d={},s=[{value:"Models",id:"models",level:2},{value:"Method name format",id:"method-name-format",level:3},{value:"Access path format",id:"access-path-format",level:3},{value:"Kinds",id:"kinds",level:3},{value:"Rules",id:"rules",level:3},{value:"Sources",id:"sources",level:3},{value:"Sinks",id:"sinks",level:3},{value:"Return Sinks",id:"return-sinks",level:3},{value:"Propagation",id:"propagation",level:3},{value:"Features",id:"features",level:3},{value:"Attach to Sources",id:"attach-to-sources",level:4},{value:"Attach to Sinks",id:"attach-to-sinks",level:4},{value:"Attach to Propagations",id:"attach-to-propagations",level:4},{value:"Add Features to Arguments",id:"add-features-to-arguments",level:4},{value:"Via-type Features",id:"via-type-features",level:4},{value:"Via-value Features",id:"via-value-features",level:4},{value:"Broadening Features",id:"broadening-features",level:4},{value:"Issue Broadening",id:"issue-broadening",level:5},{value:"Propagation Broadening",id:"propagation-broadening",level:5},{value:"Widen Broadening",id:"widen-broadening",level:5},{value:"Sanitizers",id:"sanitizers",level:3},{value:"Kind-specific Sanitizers",id:"kind-specific-sanitizers",level:4},{value:"Port-specific Sanitizers",id:"port-specific-sanitizers",level:4},{value:"Modes",id:"modes",level:3},{value:"Default model",id:"default-model",level:3},{value:"Field Models",id:"field-models",level:3},{value:"Generators",id:"generators",level:2},{value:"Example",id:"example",level:3},{value:"Specification",id:"specification",level:3},{value:"Development",id:"development",level:3},{value:"When Sources or Sinks don&#39;t appear in Results",id:"when-sources-or-sinks-dont-appear-in-results",level:4},{value:"Override the default model",id:"override-the-default-model",level:3}],m=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.mdx)("div",n)},p=m("MultiSourceSinkRule"),u=m("FbModels"),c={toc:s};function h(e){let{components:n,...a}=e;return(0,i.mdx)("wrapper",(0,t.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"The main way to configure the analysis is through defining models for methods."),(0,i.mdx)("h2",{id:"models"},"Models"),(0,i.mdx)("p",null,"A model is an abstract representation of how data flows through a method."),(0,i.mdx)("p",null,"A model essentialy consists of:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#sources"},"Sources"),": a set of sources that the method produces or receives on parameters;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#sinks"},"Sinks"),": a set of sinks on the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#propagation"},"Propagation"),": a description of how the method propagates taint coming into it (e.g, the first parameter updates the second, the second parameter updates the return value, etc.);"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#attach-to-sources"},"Attach to Sources"),": a set of features/breadcrumbs to add on an any sources flowing out of the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#attach-to-sinks"},"Attach to Sinks"),": a set of features/breadcrumbs to add on sinks of a given parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#attach-to-propagations"},"Attach to Propagations"),": a set of features/breadcrumbs to add on propagations for a given parameter or return value;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#add-features-to-arguments"},"Add Features to Arguments"),": a set of features/breadcrumbs to add on any taint that might flow in a given parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#sanitizers"},"Sanitizers"),": specifications of taint flows to stop;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#modes"},"Modes"),": a set of flags describing specific behaviors (see below).")),(0,i.mdx)("p",null,"Models can be specified in JSON. For example to mark the string parameter to our ",(0,i.mdx)("inlineCode",{parentName:"p"},"Logger.log")," function as a sink we can specify it as"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature",\n      "pattern": "Lcom/example/Logger;\\\\.log:\\\\(Ljava/lang/String;\\\\)V"\n    }\n  ],\n  "model": {\n    "sinks" : [\n      {\n        "kind" : "Logging",\n        "port" : "Argument(1)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Note that the naming of methods follow the ",(0,i.mdx)("a",{parentName:"p",href:"#method-name-format"},"Dalvik's bytecode format"),"."),(0,i.mdx)("h3",{id:"method-name-format"},"Method name format"),(0,i.mdx)("p",null,"The format used for method names is:"),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"<className>.<methodName>:(<parameterType1><parameterType2>)<returnType>")),(0,i.mdx)("p",null,"Example: ",(0,i.mdx)("inlineCode",{parentName:"p"},"Landroidx/fragment/app/Fragment;.startActivity:(Landroid/content/Intent;)V")),(0,i.mdx)("p",null,"For the parameters and return types use the following table to pick the correct one (please refer to ",(0,i.mdx)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.2-200"},"JVM doc")," for more details)"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"V - void"),(0,i.mdx)("li",{parentName:"ul"},"Z - boolean"),(0,i.mdx)("li",{parentName:"ul"},"B - byte"),(0,i.mdx)("li",{parentName:"ul"},"S - short"),(0,i.mdx)("li",{parentName:"ul"},"C - char"),(0,i.mdx)("li",{parentName:"ul"},"I - int"),(0,i.mdx)("li",{parentName:"ul"},"J - long (64 bits)"),(0,i.mdx)("li",{parentName:"ul"},"F - float"),(0,i.mdx)("li",{parentName:"ul"},"D - double (64 bits)")),(0,i.mdx)("p",null,"Classes take the form ",(0,i.mdx)("inlineCode",{parentName:"p"},"Lpackage/name/ClassName;")," - where the leading ",(0,i.mdx)("inlineCode",{parentName:"p"},"L")," indicates that it is a class type, ",(0,i.mdx)("inlineCode",{parentName:"p"},"package/name/")," is the package that the class is in."),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("strong",{parentName:"p"},"NOTE:")," Instance (i.e, non-static) method parameters are indexed starting from 1! The 0th parameter is the ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," parameter in dalvik byte-code. For static method parameter, indices start from 0.")),(0,i.mdx)("h3",{id:"access-path-format"},"Access path format"),(0,i.mdx)("p",null,"An access path describes the symbolic location of a taint. This is commonly used to indicate where a source or a sink originates from."),(0,i.mdx)("p",null,"An access path is composed of a root and a path."),(0,i.mdx)("p",null,"The root is either:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Return"),", representing the returned value;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(x)")," (where ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," is an integer), representing the parameter number ",(0,i.mdx)("inlineCode",{parentName:"li"},"x"),";")),(0,i.mdx)("p",null,"The path is a (possibly empty) list of path elements. A path element can be any of the following kinds:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"field"),": represents a field name. String encoding is a dot followed by the field name: ",(0,i.mdx)("inlineCode",{parentName:"li"},".field_name"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"index"),": represents a user defined index for dictionary like objects. String encoding uses square braces to enclose any user defined index: ",(0,i.mdx)("inlineCode",{parentName:"li"},"[index_name]"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"any index"),": represents any or unresolved indices in dictionary like objects. String encoding is an asterisk enclosed in square braces: ",(0,i.mdx)("inlineCode",{parentName:"li"},"[*]"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"index from value of"),": captures the value of the specified callable's port seen at its callsites during taint flow analysis as an ",(0,i.mdx)("inlineCode",{parentName:"li"},"index")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"any index")," (if the value cannot be resolved).\nString encoding uses ",(0,i.mdx)("em",{parentName:"li"},"argument root")," to specify the callable's port and encloses it in ",(0,i.mdx)("inlineCode",{parentName:"li"},"[<"),"...",(0,i.mdx)("inlineCode",{parentName:"li"},">]")," to represent that its value is resolved at the callsite to create an index: ",(0,i.mdx)("inlineCode",{parentName:"li"},"[<Argument(x)>]"),";")),(0,i.mdx)("p",null,"Examples:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1).name")," corresponds to the ",(0,i.mdx)("em",{parentName:"li"},"field")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"name")," of the second parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1)[name]")," corresponds to the ",(0,i.mdx)("em",{parentName:"li"},"index")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"name")," of the dictionary like second parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1)[*]")," corresponds to ",(0,i.mdx)("em",{parentName:"li"},"any index")," of the dictionary like second parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1)[<Argument(2)>]")," corresponds to an ",(0,i.mdx)("em",{parentName:"li"},"index")," of the dictionary like second parameter whose value is resolved from the third parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Return")," corresponds to the returned value;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Return.x")," correpsonds to the field ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," of the returned value;")),(0,i.mdx)("h3",{id:"kinds"},"Kinds"),(0,i.mdx)("p",null,"A source has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc).\nA sink also has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that describes the operation the method performs (e.g, execute a command, read a file, etc.).\nKinds can be arbitrary strings (e.g, ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserInput"),"). We usually avoid whitespaces."),(0,i.mdx)("h3",{id:"rules"},"Rules"),(0,i.mdx)("p",null,"A rule describes flows that we want to catch (e.g, user input flowing into command execution).\nA rule is made of a set of source kinds, a set of sink kinds, a name, a code and a description."),(0,i.mdx)("p",null,"Here is an example of a rule in JSON:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "User input flows into code execution (RCE)",\n  "code": 1,\n  "description": "Values from user-controlled source may eventually flow into code execution",\n  "sources": [\n    "UserInput",\n  ],\n  "sinks": [\n    "CodeExecution",\n  ]\n}\n')),(0,i.mdx)("p",null,"Rules used by Mariana Trench can be specified with the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--rules-paths")," argument. The default set of rules that run can be found in ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/blob/main/configuration/rules.json"},"configuration/rules.json"),"."),(0,i.mdx)(p,{mdxType:"MultiSourceSinkRule"}),(0,i.mdx)("h3",{id:"sources"},"Sources"),(0,i.mdx)("p",null,"Sources describe sources produced or received by a given method. A source can either flow out via the return value or flow via a given parameter. A source has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc)."),(0,i.mdx)("p",null,"Here is an example where the source flows by return value:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'public static String getPath() {\n    return System.getenv().get("PATH");\n}\n')),(0,i.mdx)("p",null,"The JSON model for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "kind": "UserControlled",\n      "port": "Return"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Here is an example where the source flows in via an argument:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class MyActivity extends Activity {\n  public void onNewIntent(Intent intent) {\n    // intent should be considered a source here.\n  }\n}\n")),(0,i.mdx)("p",null,"The JSON model for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "kind": "UserControlled",\n      "port": "Argument(1)"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Note that the implicit ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," parameter is considered the argument 0."),(0,i.mdx)("h3",{id:"sinks"},"Sinks"),(0,i.mdx)("p",null,"Sinks describe dangerous or sensitive methods in the code. A sink has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that represents the type of operation the method does (e.g, command execution, file system operation, etc). A sink must be attached to a given parameter of the method. A method can have multiple sinks."),(0,i.mdx)("p",null,"Here is an example of a sink:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public static String readFile(String path, String extension, int mode) {\n    // Return the content of the file path.extension\n}\n")),(0,i.mdx)("p",null,"Since ",(0,i.mdx)("inlineCode",{parentName:"p"},"path")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"extension")," can be used to read arbitrary files, we consider them sinks. We do not consider ",(0,i.mdx)("inlineCode",{parentName:"p"},"mode")," as a sink since we do not care whether the user can control it. The JSON model for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sinks": [\n    {\n      "kind": "FileRead",\n      "port": "Argument(0)"\n    },\n    {\n      "kind": "FileRead",\n      "port": "Argument(1)"\n    }\n  ]\n}\n')),(0,i.mdx)("h3",{id:"return-sinks"},"Return Sinks"),(0,i.mdx)("p",null,"Return sinks can be used to describe that a method should not return tainted information. A return sink is just a normal sink with a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Return")," port."),(0,i.mdx)("h3",{id:"propagation"},"Propagation"),(0,i.mdx)("p",null,"Propagations \u2212 also called ",(0,i.mdx)("strong",{parentName:"p"},"tito")," (Taint In Taint Out) or ",(0,i.mdx)("strong",{parentName:"p"},"passthrough")," in other tools \u2212 describe how the method propagates taint. A propagation as an ",(0,i.mdx)("strong",{parentName:"p"},"input")," (where the taint comes from) and an ",(0,i.mdx)("strong",{parentName:"p"},"output")," (where the taint is moved to)."),(0,i.mdx)("p",null,"Here is an example of a propagation:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public static String concat(String x, String y) {\n  return x + y;\n}\n")),(0,i.mdx)("p",null,"The return value of the method can be controlled by both parameters, hence it has the propagations ",(0,i.mdx)("inlineCode",{parentName:"p"},"Argument(0) -> Return")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"Argument(1) -> Return"),".  The JSON model for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "propagation": [\n    {\n      "input": "Argument(0)",\n      "output": "Return"\n    },\n    {\n      "input": "Argument(1)",\n      "output": "Return"\n    }\n  ]\n}\n')),(0,i.mdx)("h3",{id:"features"},"Features"),(0,i.mdx)("p",null,"Features (also called ",(0,i.mdx)("strong",{parentName:"p"},"breadcrumbs"),") can be used to tag a flow and help filtering issues. A feature describes a property of a flow. A feature can be any arbitrary string."),(0,i.mdx)("p",null,"For instance, the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-numerical-operator")," is used to describe that the data flows through a numerical operator such as an addition."),(0,i.mdx)("p",null,"Features are very useful to filter flows in the SAPP UI. E.g. flows with a cast from string to integer are can sometimes be less important during triaging since controlling an integer is more difficult to exploit than controlling a full string."),(0,i.mdx)("p",null,"Note that features ",(0,i.mdx)("strong",{parentName:"p"},"do not stop")," the flow, they just help triaging."),(0,i.mdx)("h4",{id:"attach-to-sources"},"Attach to Sources"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Attach to sources")," is used to add a set of ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on any sources flowing out of a method through a given parameter or return value."),(0,i.mdx)("p",null,"For instance, if we want to add the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-signed")," to all sources flowing out of the given method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public String getSignedCookie();\n")),(0,i.mdx)("p",null,"We could use the following JSON model:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "attach_to_sources": [\n    {\n      "features": ["via-signed"],\n      "port": "Return"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Note that this is only useful for sources inferred by the analysis. If you know that ",(0,i.mdx)("inlineCode",{parentName:"p"},"getSignedCookie")," returns a source of a given kind, you should use a source instead."),(0,i.mdx)("h4",{id:"attach-to-sinks"},"Attach to Sinks"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Attach to sinks")," is used to add a set of ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on all sinks on the given parameter of a method."),(0,i.mdx)("p",null,"For instance, if we want to add the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-user")," on all sinks of the given method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class User {\n  public static User findUser(String username) {\n    // The code here might use SQL, Thrift, or anything. We don't need to know.\n  }\n}\n")),(0,i.mdx)("p",null,"We could use the following JSON model:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "attach_to_sinks": [\n    {\n      "features": ["via-user"],\n      "port": "Argument(0)"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Note that this is only useful for sinks inferred by the analysis. If you know that ",(0,i.mdx)("inlineCode",{parentName:"p"},"findUser")," is a sink of a given kind, you should use a sink instead."),(0,i.mdx)("h4",{id:"attach-to-propagations"},"Attach to Propagations"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Attach to propagations")," is used to add a set of ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on all propagations from or to a given parameter or return value of a method."),(0,i.mdx)("p",null,"For instance, if we want to add the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-concat")," to the propagations of the given method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public static String concat(String x, String y);\n")),(0,i.mdx)("p",null,"We could use the following JSON model:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "attach_to_propagations": [\n    {\n      "features": ["via-concat"],\n      "port": "Return" // We could also use Argument(0) and Argument(1)\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Note that this is only useful for propagations inferred by the analysis. If you know that ",(0,i.mdx)("inlineCode",{parentName:"p"},"concat")," has a propagation, you should model it as a propagation directly."),(0,i.mdx)("h4",{id:"add-features-to-arguments"},"Add Features to Arguments"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Add features to arguments")," is used to add a set of  ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on all sources that ",(0,i.mdx)("strong",{parentName:"p"},"might")," flow on a given parameter of a method."),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Add features to arguments")," implies ",(0,i.mdx)("em",{parentName:"p"},"Attach to sources"),", ",(0,i.mdx)("em",{parentName:"p"},"Attach to sinks")," and ",(0,i.mdx)("em",{parentName:"p"},"Attach to propagations"),", but it also accounts for possible side effects at call sites."),(0,i.mdx)("p",null,"For instance:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'public static void log(String message) {\n  System.out.println(message);\n}\npublic void buyView() {\n  String username = getParameter("username");\n  String product = getParameter("product");\n  log(username);\n  buy(username, product);\n}\n')),(0,i.mdx)("p",null,"Technically, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"log")," method doesn't have any source, sink or propagation. We can use ",(0,i.mdx)("em",{parentName:"p"},"add features to arguments")," to add a feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"was-logged")," on the flow from ",(0,i.mdx)("inlineCode",{parentName:"p"},'getParameter("username")')," to ",(0,i.mdx)("inlineCode",{parentName:"p"},"buy(username, product)"),". We could use the following JSON model for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"log")," method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "add_features_to_arguments": [\n    {\n      "features": ["was-logged"],\n      "port": "Argument(0)"\n    }\n  ]\n}\n')),(0,i.mdx)("h4",{id:"via-type-features"},"Via-type Features"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Via-type")," features are used to keep track of the type of a callable\u2019s port seen at its callsites during taint flow analysis. They are specified in model generators within the \u201csources\u201d or \u201csinks\u201d field of a model with the \u201cvia_type_of\u201d field. It is mapped to a nonempty list of ports of the method for which we want to create via-type features."),(0,i.mdx)("p",null,"For example, if we were interested in the specific Activity subclasses with which the method below was called:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"\npublic void startActivityForResult (Intent intent, int requestCode);\n\n// At some callsite:\nActivitySubclass activitySubclassInstance;\nactivitySubclassInstance.startActivityForResult(intent, requestCode);\n\n")),(0,i.mdx)("p",null,"we could use the following JSON to specifiy a via-type feature that would materialize as ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-type:ActivitySubclass"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n "sinks": [\n   {\n     "port": "Argument(1)",\n     "kind": "SinkKind",\n     "via_type_of": ["Argument(0)"]\n   }\n ]\n}\n')),(0,i.mdx)("h4",{id:"via-value-features"},"Via-value Features"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Via-value")," feature captures the value of the specified callable's port seen at its callsites during taint flow analysis.  They are specified similar to ",(0,i.mdx)("inlineCode",{parentName:"p"},"Via-type"),' features -- in model generators within the "sources" or "sinks" field of a model with the "via_value_of" field. It is mapped to a nonempty list of ports of the method for which we want to create via-value features.'),(0,i.mdx)("p",null,"For example, if we were interested in the specific ",(0,i.mdx)("inlineCode",{parentName:"p"},"mode")," with which the method below was called:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'public void log (String mode, String message);\n\nclass Constants {\n  public static final String MODE = "M1";\n}\n\n// At some callsite:\nlog(Constants.MODE, "error message");\n\n')),(0,i.mdx)("p",null,"we could use the following JSON to specifiy a via-value feature that would materialize as ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-value:M1"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n "sinks": [\n   {\n     "port": "Argument(1)",\n     "kind": "SinkKind",\n     "via_value_of": ["Argument(0)"]\n   }\n ]\n}\n')),(0,i.mdx)("p",null,"Note that this only works for numeric and string literals. In cases where the argument is not a constant, the feature will appear as ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-value:unknown"),"."),(0,i.mdx)("h4",{id:"broadening-features"},"Broadening Features"),(0,i.mdx)("p",null,'Broadening features are added automatically whenever Mariana Trench makes an approximation about a taint flow. This approximation is also called "collapsing" since taint is internally represented in a tree structure where edges are fields and approximation involves placing taint onto nodes higher up in the tree. There are three kinds of broadening features that based on the reason for approximating the taint flow. These are:'),(0,i.mdx)("h5",{id:"issue-broadening"},"Issue Broadening"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-issue-broadening")," feature is added to issues where the taint flowing into the sink was not held directly on the object passed in but on one of its fields. For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"Class input = new Class();\ninput.field = source();\nsink(input); // input is not tainted, but input.field is tainted and creates an issue\n")),(0,i.mdx)("h5",{id:"propagation-broadening"},"Propagation Broadening"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-propagation-broadening")," feature is added when an object with tainted fields is propagated through a method. For correctness reasons, Mariana Trench makes the approximation that the whole object is tainted, i.e collapses all the taint from fields onto the object itself."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public Class propagate(Class argument) {\n  return argument;\n}\n\npublic void flow() {\n  Class input = new Class();\n  input.tainted_field = source();\n  Class output = propagate(input); // taint on input.tainted_field is collapsed onto input when applying propagation and it ends up on output. `via-propagation-broadening` feature is applied\n  sink(output);\n}\n")),(0,i.mdx)("h5",{id:"widen-broadening"},"Widen Broadening"),(0,i.mdx)("p",null,"For performance reasons, if a given taint tree becomes very large (either in depth or in number of nodes at a given level), Mariana Trench collapses the tree\nto a smaller size. In these cases, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-widen-broadening")," feature is added to the collapsed taint"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"Class input = new Class();\nif (\\* condition *\\) {\n  input.field1 = source();\n  input.field2 = source();\n  ...\n} else {\n  input.fieldA = source();\n  input.fieldB = source();\n  ...\n}\nsink(input); // Too many fields are sources so the whole input object becomes tainted\n")),(0,i.mdx)("h3",{id:"sanitizers"},"Sanitizers"),(0,i.mdx)("p",null,"Specifying sanitizers on a model allow us to stop taint flowing through that method. In Mariana Trench, they can be one of three types -"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),": prevent any taint sources from flowing out of the method"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),": prevent taint from reaching any sinks within the method"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"propagations"),": prevent propagations from being inferred between any two ports of the method.")),(0,i.mdx)("p",null,"These can be specified in model generators as follows -"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'"find": "methods",\n"where": ...,\n"model": {\n  "sanitizers": [\n    {"sanitize": "sources"},\n    {"sanitize": "sinks"},\n    {"sanitize": "propagations"},\n  ],\n  ...\n}\n')),(0,i.mdx)("p",null,"Note, if there are any user-specificed sources, sinks or propagations on the model, sanitizers will not affect them, but it will prevent them from being propagated outward to callsites."),(0,i.mdx)("h4",{id:"kind-specific-sanitizers"},"Kind-specific Sanitizers"),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"sources")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"sinks")," sanitizers may include a list of kinds (each with or without a partial_label) to restrict the sanitizer to only sanitizing taint of those kinds. (When unspecified, as in the example above, all taint is sanitized regardless of kind)."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'"sanitizers": [\n  {"sanitize": "sinks", "kinds": [{"kind": "SinkKindA"}, {"kind": "SinkKindB", "partial_label": "A"}]},\n]\n')),(0,i.mdx)("h4",{id:"port-specific-sanitizers"},"Port-specific Sanitizers"),(0,i.mdx)("p",null,"Sanitizers can also specify a specific port (",(0,i.mdx)("a",{parentName:"p",href:"/docs/models#access-path-format"},"access path")," root) they sanitize (ignoring all the rest). This field ",(0,i.mdx)("inlineCode",{parentName:"p"},"port")," has a slightly different meaning for each kind of sanitizer -"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),": represents the output port through which sources may not leave the method"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),": represents the input port through which taint may not trigger any sinks within the model"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"propagations"),": represents the input port through which a propagation to any other port may not be inferred")),(0,i.mdx)("p",null,"For example if the following method"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"public void someMethod(Object argument1, Object argument2) {\n  toSink(argument1);\n  toSink(argument2);\n}\n")),(0,i.mdx)("p",null,"had the following sanitizer in its model,"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'"sanitizers": [\n  {"sanitize": "sinks", "port": "Argument(1)"},\n]\n')),(0,i.mdx)("p",null,"Then a source flowing into ",(0,i.mdx)("inlineCode",{parentName:"p"},"argument1")," would be able to cause an issue, but not a source flowing into ",(0,i.mdx)("inlineCode",{parentName:"p"},"argument2"),"."),(0,i.mdx)("p",null,"Kind and port specifications may be included in the same sanitizer."),(0,i.mdx)("h3",{id:"modes"},"Modes"),(0,i.mdx)("p",null,"Modes are used to describe specific behaviors of methods. Available modes are:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"override-default"),": do not infer modes of methods using heuristics;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"skip-analysis"),": skip the analysis of the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"add-via-obscure-feature"),": add a feature/breadcrumb called ",(0,i.mdx)("inlineCode",{parentName:"li"},"via-obscure:<method>")," to sources flowing through this method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"taint-in-taint-out"),": propagate the taint on arguments to the return value and into the ",(0,i.mdx)("inlineCode",{parentName:"li"},"this")," parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"no-join-virtual-overrides"),": do not consider all possible overrides when handling a virtual call to this method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"no-collapse-on-propagation"),": do not collapse input paths when applying propagations;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"alias-memory-location-on-invoke"),": aliases existing memory location at the callsite instead of creating a new one;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"strong-write-on-propagation"),": performs a strong write from input path to the output path on propagation;")),(0,i.mdx)("h3",{id:"default-model"},"Default model"),(0,i.mdx)("p",null,"A default model is created for each method, except if it is provided by a model generator.\nThe default model has a set of heuristics:"),(0,i.mdx)("p",null,"If the method has no source code, the model is automatically marked with the modes ",(0,i.mdx)("inlineCode",{parentName:"p"},"skip-analysis")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"add-via-obscure-feature"),"."),(0,i.mdx)("p",null,"If the method has more than 40 overrides, it is marked with the mode ",(0,i.mdx)("inlineCode",{parentName:"p"},"no-join-virtual-overrides"),"."),(0,i.mdx)("p",null,"Otherwise, the default model is empty (no sources/sinks/propagations)."),(0,i.mdx)("h3",{id:"field-models"},"Field Models"),(0,i.mdx)("p",null,"These models represent user-defined taint on class fields (as opposed to methods, as described in all the previous sections on this page). They are specified in a similar way to method models as described below."),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("strong",{parentName:"p"},"NOTE:")," Field sources should not be applied to fields that are both final and of a primitive type (",(0,i.mdx)("inlineCode",{parentName:"p"},"int"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"char"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"float"),", etc as well as ",(0,i.mdx)("inlineCode",{parentName:"p"},"java.lang.String"),") as the Java compiler optimizes accesses of these fields in the bytecode into accesses of the constant value they hold. In this scenario, Mariana Trench has no way of recognizing that the constant was meant to carry a source.")),(0,i.mdx)("p",null,"Example field model generator for sources:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'"find": "fields",\n"where": [\n  {\n    "constraint": "name",\n    "pattern": "SOURCE_EXAMPLE"\n  }\n],\n"model": {\n  "sources" : [\n    {\n      "kind": "FieldSource"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Example code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public class TestClass {\n  // Field that we know to be tainted\n  public Object SOURCE_EXAMPLE = ...;\n\n  void flow() {\n    sink(EXAMPLE, ...);\n  }\n}\n")),(0,i.mdx)("p",null,"Example field model generator for sinks:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'"find": "fields",\n"where": [\n  {\n    "constraint": "name",\n    "pattern": "SINK_EXAMPLE"\n  }\n],\n"model": {\n  "sinks" : [\n    {\n      "kind": "FieldSink"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Example code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public class TestClass {\n  public Object SINK_EXAMPLE = ...;\n\n  void flow() {\n    SINK_EXAMPLE = source();\n  }\n}\n")),(0,i.mdx)("p",null,"Field signature formats follow the Dalvik bytecode format similar to methods as discussed ",(0,i.mdx)("a",{parentName:"p",href:"#method-name-format"},"above"),". This is of the form ",(0,i.mdx)("inlineCode",{parentName:"p"},"<className>.<fieldName>:<fieldType>"),"."),(0,i.mdx)("h2",{id:"generators"},"Generators"),(0,i.mdx)("p",null,"Mariana Trench allows for dynamic model specifications. This allows a user to specify models of methods before running the analysis. This is used to specify sources, sinks, propagation and modes."),(0,i.mdx)("p",null,"Model generators are specified in a generator configuration file, specified by the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--generator-configuration-path")," parameter. By default, we use ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/blob/main/configuration/default_generator_config.json"},(0,i.mdx)("inlineCode",{parentName:"a"},"default_generator_config.json")),"."),(0,i.mdx)("h3",{id:"example"},"Example"),(0,i.mdx)("p",null,"Examples of model generators are located in the ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/tree/main/configuration/model-generators"},(0,i.mdx)("inlineCode",{parentName:"a"},"configuration/model-generators"))," directory."),(0,i.mdx)("p",null,"Below is an example of a JSON model generator:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "model_generators": [\n      {\n        "find": "methods",\n        "where": [\n          { "constraint": "name", "pattern": "toString" }\n        ],\n        "model": {\n          "propagation": [\n            {\n              "input": "Argument(0)",\n              "output": "Return"\n            }\n          ]\n        }\n      },\n      {\n        "find": "methods",\n        "where": [\n          {\n            "constraint": "parent",\n            "inner": {\n              "constraint": "extends",\n              "inner": {\n                "constraint": "name", "pattern": "SandcastleCommand"\n              }\n            }\n          },\n          { "constraint": "name", "pattern": "Time" }\n        ],\n        "model": {\n          "sources": [\n            {\n              "kind": "Source",\n              "port": "Return"\n            }\n          ]\n        }\n      },\n      {\n        "find": "methods",\n        "where": [\n          { "constraint": "parent", "inner": { "constraint": "extends", "inner": { "constraint": "name", "pattern": "IEntWithPurposePolicy" }} },\n          { "constraint": "name", "pattern": "gen.*" },\n          { "constraint": "parameter", "idx": 0, "inner": { "constraint": "type", "kind": "extends", "class": "IViewerContext" } },\n          { "constraint": "return", "inner": { "constraint": "extends", "inner": { "constraint": "name", "pattern": "Ent" } } }\n        ],\n        "model": {\n          "modes": ["add-via-obscure-feature"],\n          "sinks": [\n            {\n              "kind": "Sink",\n              "port": "Argument(0)",\n              "features": ["via-gen"]\n            }\n          ]\n        }\n      }\n  ]\n}\n')),(0,i.mdx)("h3",{id:"specification"},"Specification"),(0,i.mdx)("p",null,"Each JSON file is a JSON object with a key ",(0,i.mdx)("inlineCode",{parentName:"p"},"model_generators"),' associated with a list of "rules".'),(0,i.mdx)("p",null,'Each "rule" defines a "filter" (which uses "constraints" to specify methods for which a "model" should be generated) and a "model". A rule has the following key/values:'),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"find"),": The type of thing to find. We support ",(0,i.mdx)("inlineCode",{parentName:"p"},"methods")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"fields"),";")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"where"),': A list of "constraints". All constraints ',(0,i.mdx)("strong",{parentName:"p"},"must be satisfied")," by a method or field in order to generate a model for it. All the constraints are listed below, grouped by the type of object they are applied to:"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Method"),":"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"signature"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the full signature (class, method, argument types) of a method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parent"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the class holding the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parameter"),": Expects an extra properties ",(0,i.mdx)("inlineCode",{parentName:"li"},"idx")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Parameter]"," or ","[Type]",", matches when the idx-th parameter of the function or method matches the nested constraint inner;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"return"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the return of the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_static | is_constructor | is_native | has_code"),": Accepts an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"false"),". By default, ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," is considered ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"number_parameters"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply to the number of parameters (counting the implicit ",(0,i.mdx)("inlineCode",{parentName:"li"},"this")," parameter);"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"number_overrides"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply on the number of method overrides."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Parameter:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parameter_has_annotation"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"type")," and an optional property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern"),", respectively a string and a regex fully matching the value of the parameter annotation."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Type:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"extends"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply to one of the base classes or itself. The optional property ",(0,i.mdx)("inlineCode",{parentName:"li"},"includes_self")," is a boolean that tells whether the constraint must be applied on the type itself or not;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"super"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply on the direct superclass;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_class | is_interface"),": Accepts an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"false"),". By default, ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," is considered ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),";"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Field"),":"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"signature"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the full signature of the field. This is of the form ",(0,i.mdx)("inlineCode",{parentName:"li"},"<className>.<fieldName>:<fieldType>"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parent"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the class holding the field;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_static"),": Accepts an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"false"),". By default, ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," is considered ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),";"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Method, Type or Field:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"name"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the name of the item;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"has_annotation"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"type")," and an optional property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern"),", respectively a string and a regex fully matching the value of the annotation."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"visibility"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"is")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"public"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"private")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"protected"),"; (Note this does not apply to ",(0,i.mdx)("inlineCode",{parentName:"li"},"Field"),")"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Integer:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"< | <= | == | > | >= | !="),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which contains an integer that the input integer is compared with. The input is the left hand side."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Any (Method, Parameter, Type, Field or Integer):")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"all_of"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints which must all apply;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"any_of"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints where one of them must apply;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"not"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Any]"," which contains a nested constraint that should not apply. (Note this is not yet implemented for ",(0,i.mdx)("inlineCode",{parentName:"li"},"Field"),"s)"))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"model"),": A model, describing sources/sinks/propagations/etc."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"For method models"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),"*: A list of sources, i.e a source flowing out of the method via return value or flowing in via an argument. A source has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The source name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),"**: The source access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumbs names;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"via_type_of"),"*: A list of ports;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),"*: A list of sinks, i.e describing that a parameter of the method flows into a sink. A sink has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The sink name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The sink access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*:  A list of features/breadcrumbs names;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"via_type_of"),"*: A list of ports;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"propagation"),"*: A list of propagations (also called passthrough) that describe whether a taint on a parameter should result in a taint on the return value or another parameter. A propagation has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"input"),": The input access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"output"),": The output access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(2)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumbs names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"attach_to_sources"),"*: A list of attach-to-sources that describe that all sources flowing out of the method on the given parameter or return value must have the given features. An attach-to-source has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"attach_to_sinks"),"*: A list of attach-to-sinks that describe that all sources flowing in the method on the given parameter must have the given features. An attach-to-sink has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"attach_to_propagations"),"*: A list of attach-to-propagations that describe that inferred propagations of sources flowing in or out of a given parameter or return value  must have the given features. An attach-to-propagation has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"add_features_to_parameters"),"*: A list of add-features-to-parameters that describe that flows that might flow on the given parameter must have the given features. An add-features-to-parameter has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"modes"),"*: A list of mode names that describe specific behaviors of a method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"for_all_parameters"),": Generate sources/sinks/propagations/attach",(0,i.mdx)("em",{parentName:"li"},"to"),"* for all parameters of a method that satisfy some constraints. It accepts the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"variable"),": A symbolic name for the parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"where"),": An optional list of ","[Parameter]"," or ","[Type]"," constraints on the parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources | sinks | propagation"),': Same as under "model", but we accept the variable name as a parameter number.'))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"verbosity"),"*: A logging level, to help debugging. 1 is the most verbose, 5 is the least. The default verbosity level is 5.")))),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"For Field models"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),"*: A list of sources the field should hold. A source has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The source name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumbs names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),"*: A list of sinks the field should hold. A sink has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The sink name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumds names;")))))),(0,i.mdx)("p",null,"In the above bullets,"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"*")," denotes optional key/value."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"**")," denotes optional key/value. Default is ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"'),".")),(0,i.mdx)("p",null,"Note, the implicit ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," parameter for methods has the parameter number 0."),(0,i.mdx)("h3",{id:"development"},"Development"),(0,i.mdx)("h4",{id:"when-sources-or-sinks-dont-appear-in-results"},"When Sources or Sinks don't appear in Results"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"This could be because your model generator did not find any method matching your query. You can use the ",(0,i.mdx)("inlineCode",{parentName:"p"},'"verbosity": 1')," option in your model generator to check if it matched any method. For instance:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "model_generators":. [\n    {\n      "find": "methods",\n      "where": /* ... */,\n      "model": {\n        /* ... */\n      },\n      "verbosity": 1\n    }\n  ]\n}\n')),(0,i.mdx)("p",{parentName:"li"},"When running mariana trench, this should print:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre"},"INFO Method `...` satisfies all constraints in json model generator ...\n"))),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Make sure that your model generator is actually running. You can use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--verbosity 2")," option to check that. Make sure your model generator is specified in ",(0,i.mdx)("inlineCode",{parentName:"p"},"configuration/default_generator_config.json"),".")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"You can also check the output models.\nUse ",(0,i.mdx)("inlineCode",{parentName:"p"},"grep SourceKind models@*")," to see if your source or sink kind exists.\nUse ",(0,i.mdx)("inlineCode",{parentName:"p"},"grep 'Lcom/example/<class-name>;.<method-name>:' models@*")," to see if a given method exists in the app."))),(0,i.mdx)("h3",{id:"override-the-default-model"},"Override the default model"),(0,i.mdx)("p",null,"Mariana trench generates a default model for each method (",(0,i.mdx)("a",{parentName:"p",href:"/docs/models#default-model"},"see above"),") using a set of heuristics."),(0,i.mdx)("p",null,"Users can use a ",(0,i.mdx)("a",{parentName:"p",href:"/docs/models#generators"},"model generator")," to override the default behavior. This can be done to:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Stop a method from propagating the taint (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},"escape")," functions);"),(0,i.mdx)("li",{parentName:"ul"},"Skip the analysis of a slow method;"),(0,i.mdx)("li",{parentName:"ul"},"Avoid considering all overrides when handling a virtual method call;"),(0,i.mdx)("li",{parentName:"ul"},"Etc..")),(0,i.mdx)("p",null,"In order to do that, one needs to create a model using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"override-default")," mode, with any additional modes:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"auto model = Model(method, /* modes */ Model::Mode::OverrideDefault | Model::Mode::NoJoinVirtualOverrides);\n")),(0,i.mdx)("p",null,"NOTE: If you get the error ",(0,i.mdx)("inlineCode",{parentName:"p"},"Attempting to analyze method <name> with no code!"),", it probably means that you forgot to mark the method with ",(0,i.mdx)("inlineCode",{parentName:"p"},"Model::Mode::SkipAnalysis")),(0,i.mdx)(u,{mdxType:"FbModels"}))}h.isMDXComponent=!0}}]);